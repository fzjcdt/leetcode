## 21.Merge Two Sorted Lists
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

```
public class P21 {
    /*
     * 简单归并，用原来的节点
     */
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode rst = new ListNode(0);
        ListNode head = rst;

        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                rst.next = l1;
                l1 = l1.next;
            } else {
                rst.next = l2;
                l2 = l2.next;
            }

            rst = rst.next;
        }

        rst.next = l1 == null ? l2 : l1;

        return head.next;
    }

    public static void main(String[] args) {
        P21 p = new P21();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(1);
        ListNode node1 = p.new ListNode(2);
        ListNode node2 = p.new ListNode(4);
        ListNode node3 = p.new ListNode(3);
        ListNode node4 = p.new ListNode(4);
        l1.next = node1;
        node1.next = node2;
        l2.next = node3;
        node3.next = node4;

        ListNode l = p.mergeTwoLists(l1, l2);
        while (l != null) {
            System.out.println(l.val);
            l = l.next;
        }
    }
}

```


## 22.Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]


```

import java.util.ArrayList;
import java.util.List;

public class P22 {
    /*
     * 简单搜索
     */

    public void dfs(int n, int leftParentheseNum, int rightParentheseNum, StringBuilder str, List<String> rst) {
        if (n == leftParentheseNum && n == rightParentheseNum) {
            rst.add(str.toString());
            return;
        } else {
            // 左括号不够
            if (leftParentheseNum <= n) {
                str.append('(');
                dfs(n, leftParentheseNum + 1, rightParentheseNum, str, rst);
                str.deleteCharAt(leftParentheseNum + rightParentheseNum);
            }

            // 右括号还小于左括号
            if (leftParentheseNum > rightParentheseNum) {
                str.append(')');
                dfs(n, leftParentheseNum, rightParentheseNum + 1, str, rst);
                str.deleteCharAt(leftParentheseNum + rightParentheseNum);
            }
        }
    }

    public List<String> generateParenthesis(int n) {
        List<String> rst = new ArrayList<String>();
        if (n == 0) {
            return rst;
        }
        dfs(n, 0, 0, new StringBuilder(), rst);

        return rst;
    }

    public static void main(String[] args) {
        P22 p = new P22();
        List<String> list = p.generateParenthesis(3);
        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

## 23.Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
```
import java.util.Comparator;
import java.util.PriorityQueue;

public class P23 {
    /*
     * 暴力求解时间复杂度为O(kn)，k为lists.length，n为总节点数。每次遍历k次，可以得到一个节点，总共n个节点
     * 用优先队列(堆)，时间复杂度为O(nlogk)，每次得到一个节点只需要logk次
     */
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // 优先队列的使用
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>() {

            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val) {
                    return -1;
                } else if (o1.val > o2.val) {
                    return 1;
                }
                return 0;
            }
        });

        ListNode head = new ListNode(0);
        ListNode rst = head;

        for (ListNode l : lists) {
            if (l != null) {
                queue.add(l);
            }
        }

        // 每次添加最小的元素，如果它的下一个元素不为null，则再添加进队列
        while (!queue.isEmpty()) {
            rst.next = queue.poll();
            rst = rst.next;
            if (rst.next != null) {
                queue.add(rst.next);
            }
        }

        return head.next;
    }

    public static void main(String[] args) {
        P23 p = new P23();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        ListNode l5 = p.new ListNode(5);
        l1.next = l4;
        l2.next = l5;

        ListNode[] lists = {l1, l2, l3};
        ListNode rst = p.mergeKLists(lists);

        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```


## 24.Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

```
public class P24 {
    /*
     * 1 -> 2 -> 3 -> 4
     * 2 -> 1 -> 4 -> 3
     */

    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode rst = new ListNode(0);
        ListNode temp = rst;

        ListNode left = head;
        ListNode right = head.next;

        /*
         * left和right指向相邻两个节点
         * temp先指向right，再指向left
         * 记得right结束后往后移，否则会丢失位置
         * left.next要指向right，不然会有环，即最后两个节点相互指向
         */
        while (right != null) {
            temp.next = right;
            temp = temp.next;
            right = right.next;
            temp.next = left;
            temp = temp.next;
            left.next = right;
            if (right != null) {
                left = right;
                right = left.next;
            }
        }

        return rst.next;
    }

    public static void main(String[] args) {
        P24 p = new P24();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;

        ListNode rst = p.swapPairs(l1);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```
```
public class P24_new {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    /*
     * 简洁的递归写法，但占用空间较大
     */
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        /*
         * 假设swapPairs能翻转head及之后的节点，并返回翻转之后的头节点
         */
        ListNode node = head.next;
        head.next = swapPairs(head.next.next);
        node.next = head;

        return node;
    }

    public static void main(String[] args) {
        P24_new p = new P24_new();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;

        ListNode rst = p.swapPairs(l1);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```


## 25.Reverse Nodes in k-Group
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed. 一定内存，所以不好用递归，不然会简单挺多
For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

```
public class P25 {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        int len = 0;
        ListNode temp = head;
        // 计算链表长度
        while (temp != null) {
            len++;
            temp = temp.next;
        }

        // k = 1， 或者链表长度不到k，直接返回
        if (k <= 1 || len < k) {
            return head;
        }

        ListNode rst = new ListNode(0);
        // 上次前面翻转后的最后一个节点，要指向后面翻转后的第一个节点，专门用一个变量记录一下
        ListNode lastTimeLastNode = rst;

        ListNode curPos = head;
        ListNode pre, cur, next;

        for (int i = k; i <= len; i += k) {
            pre = curPos;
            cur = pre.next;
            next = cur.next;
            // k - 1次，把k - 1个next指向前面节点
            for (int j = 1; j < k; j++) {
                cur.next = pre;
                pre = cur;
                cur = next;
                if (next != null) {
                    next = next.next;
                }
            }

            /* 上面循环结束后的结果
             *  1 -> 2 -> 3 -> 4 -> 5
             *  p    c    n
             *
             *  1-><-2    3 -> 4 -> 5
             *       p    c    n
             *
             *  1-><-2 <- 3    4 -> 5
             *            p    c    n
             */
            // 上次的最后一个节点的next指向本次翻转后的第一个节点3
            lastTimeLastNode.next = pre;
            // lastTimeLastNode变成1
            lastTimeLastNode = curPos;
            // 本轮翻转后的节点的最后一个（1），指向下一次的第一个（4）（后面反转后可能不是第一个节点，但如果后面没有k个节点，则是，这样能保证）
            curPos.next = cur;
            // 准备下一次
            curPos = cur;
        }

        return rst.next;
    }

    public static void main(String[] args) {
        P25 p = new P25();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        ListNode l5 = p.new ListNode(5);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;
        l4.next = l5;

        ListNode rst = p.reverseKGroup(l1, 3);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}

```


## 26.Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the new length.

```
public class P26 {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }

        int pos = 0;
        for (int i = 1, len = nums.length; i < len; i++) {
            // 和前一个数一样，跳过
            if (nums[i] == nums[i - 1]) {
                continue;
            }

            // 否则pos+1等于这个数
            nums[++pos] = nums[i];
        }

        return pos + 1;
    }

    public static void main(String[] args) {
        P26 p = new P26();
        int[] nums = {1, 1, 2};
        System.out.println(p.removeDuplicates(nums));
    }
}
```


## 27.Remove Element
Given an array and a value, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

```

public class P27 {
    public int removeElement(int[] nums, int val) {
        // 等于val跳过，否则pos位置换做它
        int pos = 0;
        for (int i = 0, len = nums.length; i < len; i++) {
            if (nums[i] != val) {
                nums[pos++] = nums[i];
            }
        }

        return pos;
    }

    public static void main(String[] args) {
        P27 p = new P27();
        int[] nums = {3, 2, 2, 3};
        System.out.println(p.removeElement(nums, 3));
    }
}
```


## 28.Implement strStr()
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2


Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1

```
public class P28 {
    /*
     * KMP匹配
     */

    public int[] getNext(String s) {
        int len = s.length();
        int[] next = new int[len + 1];
        next[0] = -1;
        int k = -1, j = 0;

        while (j < len) {
            if (k == -1 || s.charAt(j) == s.charAt(k)) {
                k++;
                j++;
                next[j] = k;
            } else {
                k = next[k];
            }
        }

        return next;
    }

    public int strStr(String haystack, String needle) {
        int[] next = getNext(needle);
        int hLen = haystack.length();
        int nLen = needle.length();

        int i = 0, j = 0;
        while (i < hLen && j < nLen) {
            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }

        if (j == nLen) {
            return i - nLen;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        P28 p = new P28();
        System.out.println(p.strStr("abaaa", "aab"));
    }
}
```


## 29.Divide Two Integers	
Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.

```
public class P29 {

    public long dfs(long dividend, long divisor) {
        if (dividend < divisor) {
            return 0;
        }

        long rst = 1, temp = divisor;
        /*
         * 每次加倍，一直到不能加为止
         */
        while ((dividend >> 1) >= temp) {
            temp = temp + temp;
            rst = rst + rst;
        }

        return rst + dfs(dividend - temp, divisor);
    }

    public int divide(int dividend, int divisor) {
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        } else if (divisor == 1) {
            return dividend;
        }

        /*
         * 都转成正数，加个符号位
         */
        int sign = 1;
        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {
            sign = -1;
        }

        long dividend_ = (long) dividend;
        long divisor_ = (long) divisor;

        /*
         * 如果是Integer.MIN_VALUE，abs无效，所以干脆用long
         */
        dividend_ = Math.abs(dividend_);
        divisor_ = Math.abs(divisor_);

        long rst = dfs(dividend_, divisor_);

        if (sign == -1) {
            rst = 0 - rst;
        }

        return (int) rst;
    }

    public static void main(String[] args) {
        P29 p = new P29();
        System.out.println(p.divide(-2147483648, 2));
    }
}
```


## 30.Substring with Concatenation of All Words
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

For example, given:
s: "barfoothefoobarman"
words: ["foo", "bar"]

You should return the indices: [0,9].
(order does not matter).

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class P30 {
    /*
     * 时间复杂度为O(kn)，n为s长度，k为words长度
     * 因为words的长度固定，每次截取相同的长度
     * 用hashMap判断是否完全匹配
     */

    public List<Integer> findSubstring(String s, String[] words) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        List<Integer> rst = new ArrayList<Integer>();

        // words为空，或者s的长度小于每个单词的长度*单词数(总单词长度)
        if (words.length == 0 || words[0].length() * words.length > s.length()) {
            return rst;
        }

        // 将words里的单词加入map
        for (int i = 0, len = words.length; i < len; i++) {
            if (map.containsKey(words[i])) {
                map.put(words[i], map.get(words[i]) + 1);
            } else {
                map.put(words[i], 1);
            }
        }

        int eachWordLen = words[0].length();
        int totalWordsLen = eachWordLen * words.length;
        boolean isAResult = true;
        String str = "";
        Map<String, Integer> curMap = new HashMap<String, Integer>();

        // 遍历s
        for (int i = 0, sLen = s.length(); i <= sLen - totalWordsLen; i++) {
            curMap.clear();
            isAResult = true;
            // 每次截取s中eachWordLen的单词
            for (int j = i; j < i + totalWordsLen; j += eachWordLen) {
                str = s.substring(j, j + eachWordLen);
                // 在map中，则加入curMap
                if (map.containsKey(str)) {
                    if (curMap.containsKey(str)) {
                        // 比map中多了，不符合条件
                        if (curMap.get(str) >= map.get(str)) {
                            isAResult = false;
                            break;
                        }
                        curMap.put(str, curMap.get(str) + 1);
                    } else {
                        curMap.put(str, 1);
                    }
                } else {
                    isAResult = false;
                    break;
                }
            }

            if (isAResult) {
                rst.add(i);
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P30 p = new P30();
        String[] words = {"foo", "bar"};
        List<Integer> rst = p.findSubstring("foobarffbarfoo", words);

        for (Integer t : rst) {
            System.out.println(t);
        }
    }
}

```


## 31.Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

```
import java.util.Arrays;

public class P31 {
    public void nextPermutation(int[] nums) {
        if (nums.length <= 1) {
            return;
        }

        int lastIncreasePos = 0, changePos = 0;
        for (int i = 1, len = nums.length; i < len; i++) {
            if (nums[i] > nums[i - 1]) {
                lastIncreasePos = i;
                changePos = i;
            } else if (lastIncreasePos != 0 && nums[i] < nums[changePos] && nums[i] > nums[lastIncreasePos - 1]) {
                changePos = i;
            }
        }

        /*
         * 下面排序是个败笔，从O(n)变成了O(nlogn)，用new里的reverse，因为后面的数一定是递减的
         */
        if (lastIncreasePos == 0) {
            Arrays.sort(nums);
        } else {
            int temp = nums[changePos];
            nums[changePos] = nums[lastIncreasePos - 1];
            nums[lastIncreasePos - 1] = temp;
            Arrays.sort(nums, lastIncreasePos, nums.length);
        }

        for (int i : nums) {
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        P31 p = new P31();
        /*
         * 1 3 2 -> 2 1 3
         */
        int[] nums = {2, 1, 3};
        p.nextPermutation(nums);
    }
}
```

```
public class P31_new {
    public void reverse(int[] nums, int start) {
        int temp, end = nums.length - 1;
        while (start < end) {
            temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;

            start++;
            end--;
        }
    }

    public void nextPermutation(int[] nums) {
        if (nums.length <= 1) {
            return;
        }

        int lastIncreasePos = 0, changePos = 0;
        /*
         * 从前往后找（new_new里从后往前可能会更好一些）最后一个递增的序列位置，并找到交换的位置，即比最后一个递增序列前一个数大，比它小
         */
        for (int i = 1, len = nums.length; i < len; i++) {
            if (nums[i] > nums[i - 1]) {
                lastIncreasePos = i;
                changePos = i;
                // 下面需要等，如果是排序不用，但用reverse需要，比如 1 3 3，不等的话变成3 1 3，再交换变成3 3 1就不对了
            } else if (lastIncreasePos != 0 && nums[i] <= nums[changePos] && nums[i] > nums[lastIncreasePos - 1]) {
                changePos = i;
            }
        }

        if (lastIncreasePos == 0) {
            reverse(nums, 0);
        } else {
            int temp = nums[changePos];
            nums[changePos] = nums[lastIncreasePos - 1];
            nums[lastIncreasePos - 1] = temp;
            reverse(nums, lastIncreasePos);
        }

        for (int i : nums) {
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        P31_new p = new P31_new();
        /*
         * 1 3 2 -> 2 1 3
         */
        int[] nums = {2, 3, 1, 3, 3};
        p.nextPermutation(nums);
    }
}
```

```
public class P31_new_new {
    public void reverse(int[] nums, int start) {
        int temp, end = nums.length - 1;
        while (start < end) {
            temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;

            start++;
            end--;
        }
    }

    public void nextPermutation(int[] nums) {
        if (nums.length <= 1) {
            return;
        }

        int i = nums.length - 1;
        // 从后往前，找到第一个前一个数小于后一个数的位置, 需要等号
        while (i > 0 && nums[i - 1] >= nums[i]) {
            i--;
        }

        i--;
        if (i >= 0) {
            // 从后往前找到第一个大于nums[i]的数交换
            for (int j = nums.length - 1; j > i; j--) {
                if (nums[j] > nums[i]) {
                    int temp = nums[j];
                    nums[j] = nums[i];
                    nums[i] = temp;
                    break;
                }
            }
        }

        reverse(nums, i + 1);

        for (int t : nums) {
            System.out.println(t);
        }
    }

    public static void main(String[] args) {
        P31_new_new p = new P31_new_new();
        /*
         * 1 3 2 -> 2 1 3
         */
        int[] nums = {2, 3, 1, 3, 3};
        p.nextPermutation(nums);
    }
}
```



## 32.Longest Valid Parentheses
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.

```
import java.util.Stack;

public class P32 {
    /*
     * O(n)空间和时间
     */
    public int longestValidParentheses(String s) {
        int rst = 0;
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(-1);

        for (int i = 0, len = s.length(); i < len; i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                // 因为一开始push了-1，为空的时候说明多了一个)，最左边有效的(是下一个，所以push当前的i
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    // stack栈顶一直存放有效的(位置
                    rst = Math.max(rst, i - stack.peek());
                }
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P32 p = new P32();
        // "(()"
        // "(()()"
        // "()(()"
        System.out.println(p.longestValidParentheses("(()()"));
    }
}
```
```
public class P32_new {
    /*
     * O(n)空间和时间
     * dp[i]表示以i结尾的最长有效括号
     * 状态转移方程
     * dp[i] == 0   if s[i] == '('
     * dp[i] == dp[i - 1] + 2   if s[i] == ')' and s[i - 1] == '('
     * dp[i] == dp[i - 2] + 2 + dp[i - dp[i - 1] - 2]   if s[i] == ')' and s[i - 1] == ')' and s[i - dp[i - 1] -1] = '('
     */
    public int longestValidParentheses(String s) {
        int[] dp = new int[s.length() + 1];
        dp[0] = 0;
        int rst = 0;

        for (int i = 1, len = s.length(); i < len; i++) {
            if (s.charAt(i) == '(') {
                dp[i] = 0;
            } else {
                if (s.charAt(i - 1) == '(') {
                    // ....()
                    dp[i] = 2 + (i >= 2 ? dp[i - 2] : 0);
                } else {
                    // ...))
                    /*
                     *     0 1 2 3 4 5
                     *     ( ) ( ( ) )
                     * dp  0 2 0 0 2 6
                     */

                    // ()) 要小心越界
                    if (i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                        dp[i] = 2 + dp[i - 1] + (i - dp[i - 1] - 2 >= 0 ? dp[i - dp[i - 1] - 2] : 0);
                    } else {
                        dp[i] = 0;
                    }
                }
            }

            // 最长有效括号不一定在最右边
            rst = Math.max(rst, dp[i]);
        }

        return rst;
    }

    public static void main(String[] args) {
        P32_new p = new P32_new();
        // "(()"
        // "(()()"
        // "()(()"
        System.out.println(p.longestValidParentheses("()(()"));
    }
}
```
```
public class P32_new_new {
    /*
     * O(n)时间，O(1)空间
     */
    public int longestValidParentheses(String s) {
        int rst = 0;
        int leftCount = 0, rightCount = 0;
        /*
         * 左括号比右括号多是合法的
         * 左右括号一样多，说明前面完全匹配了，
         * 右括号比左括号多说明不匹配
         */
        for (int i = 0, len = s.length(); i < len; i++) {
            if (s.charAt(i) == '(') {
                leftCount++;
            } else {
                rightCount++;
            }

            if (leftCount == rightCount) {
                rst = Math.max(rst, leftCount * 2);
            } else if (leftCount < rightCount) {
                leftCount = 0;
                rightCount = 0;
            }
        }

        /*
         * 仅仅从左边开始，(()(())会算成只有两个
         */
        leftCount = 0;
        rightCount = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == ')') {
                rightCount++;
            } else {
                leftCount++;
            }

            if (leftCount == rightCount) {
                rst = Math.max(rst, leftCount * 2);
            } else if (leftCount > rightCount) {
                leftCount = 0;
                rightCount = 0;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P32_new_new p = new P32_new_new();
        System.out.println(p.longestValidParentheses("()(())"));
    }
}
```


## 33.Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

```
public class P33 {
    /*
     * 时间复杂度O(logn)
     * 用二分，再根据nums[mid]和nums[0]的关系判断该舍弃哪边
     */

    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1, mid;

        while (left <= right) {
            mid = (left + right) / 2;
            if (nums[mid] > target) {
                // mid在右半部分
                if (nums[mid] < nums[0]) {
                    right = mid - 1;
                } else {
                    // mid在左半部分
                    // target比左半部分最小的还小，说明在右边
                    if (target < nums[left]) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
            } else if (nums[mid] < target) {
                // mid在右半部分
                if (nums[mid] < nums[0]) {
                    // target大于右半部分最大的，说明在左边
                    if (target > nums[right]) {
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                } else {
                    // mid 在左半部分
                    left = mid + 1;
                }
            } else {
                return mid;
            }
        }

        return -1;
    }

    public static void main(String[] args) {
        P33 p = new P33();
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        System.out.println(p.search(nums, 6));
    }
}

```
```
public class P33_new {
    /*
     * 先用二分找到翻转的位置，再根据target和nums[0]的大小关系判断在哪边，再用二分查找
     * 时间复杂度O(logn)
     */

    public int search(int[] nums, int target) {
        if (nums.length == 0) {
            return -1;
        }

        int minIndex = findMinIndex(nums);
        int start, end, mid;

        if (target >= nums[0]) {
            start = 0;
            // 注意midIndex为0时，相当于没有翻转
            end = minIndex == 0 ? nums.length - 1 : minIndex - 1;
        } else {
            start = minIndex;
            end = nums.length - 1;
        }

        while (start <= end) {
            mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        return -1;
    }

    public int findMinIndex(int[] nums) {
        int start = 0, end = nums.length - 1, mid, rst = 0;

        while (start <= end) {
            mid = start + (end - start) / 2;

            // 这里不能等
            // 1 2 3 4 这样的序列也能求解，因为nums[mid]不会小于nums[0]，所以rst一直为0，是正确的
            if (nums[mid] < nums[0]) {
                rst = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P33_new p = new P33_new();
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        System.out.println(p.search(nums, 6));
    }
}
```

## 34.Find First and Last Position of Element in Sorted Array	
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

```
public class P34 {
    /*
     * 时间复杂度O(logn)
     * 先找左边界，等于的时候判断一下左边的数是否等于nums[mid]，是的话再往左边二分
     * 再找右边界
     */

    public int[] searchRange(int[] nums, int target) {
        int[] rst = {-1, -1};
        int start = 0, end = nums.length - 1, mid, temp = -1;

        while (start <= end) {
            mid = start + (end - start) / 2;
            if (nums[mid] > target) {
                end = mid - 1;
            } else if (nums[mid] < target) {
                start = mid + 1;
            } else {
                temp = mid;
                if (mid > 0 && nums[mid - 1] == nums[mid]) {
                    end = mid - 1;
                } else {
                    break;
                }
            }
        }

        if (temp != -1) {
            rst[0] = temp;
        } else {
            return rst;
        }

        temp = -1;
        start = 0;
        end = nums.length - 1;

        while (start <= end) {
            mid = start + (end - start) / 2;
            if (nums[mid] > target) {
                end = mid - 1;
            } else if (nums[mid] < target) {
                start = mid + 1;
            } else {
                temp = mid;
                if (mid < nums.length - 1 && nums[mid + 1] == nums[mid]) {
                    start = mid + 1;
                } else {
                    break;
                }
            }
        }

        rst[1] = temp;

        return rst;
    }

    public static void main(String[] args) {
        P34 p = new P34();
        int[] nums = {1, 2, 2, 6, 6, 8};
        int[] rst = p.searchRange(nums, 6);
        System.out.println(rst[0] + " " + rst[1]);
    }
}
```


## 35.Search Insert Position
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2


Example 2:

Input: [1,3,5,6], 2
Output: 1


Example 3:

Input: [1,3,5,6], 7
Output: 4


Example 1:

Input: [1,3,5,6], 0
Output: 0


```
public class P35 {
    /*
     * 简单二分
     */
    public int searchInsert(int[] nums, int target) {
        int start = 0, end = nums.length - 1, mid, rst = 0;

        while (start <= end) {
            mid = start + (end - start) / 2;

            // 甚至不用rst，因为rst和start的操作是一样的，最后返回start就好
            if (nums[mid] < target) {
                // 注意mid + 1，因为nums[mid]比target小，插入的位置是mid的后面
                rst = mid + 1;
                start = mid + 1;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                return mid;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P35 p = new P35();
        int[] nums = {1, 2, 3, 5, 7, 8};
        System.out.println(p.searchInsert(nums, 10));
    }
}
```

## 36.Valid Sudoku
Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.

The Sudoku board could be partially filled, where empty cells are filled with the character '.'.



A partially filled sudoku which is valid.
Note:
A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.

```
import java.util.HashMap;
import java.util.Map;

public class P36 {
    public boolean isValidSudoku(char[][] board) {
        /*
         * 每行每列不重复
         */
        for (int i = 0; i < 9; i++) {
            Map<Character, Integer> row_map = new HashMap<Character, Integer>();
            Map<Character, Integer> column_map = new HashMap<Character, Integer>();

            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    if (row_map.containsKey(board[i][j])) {
                        return false;
                    } else {
                        row_map.put(board[i][j], 1);
                    }
                }
                if (board[j][i] != '.') {
                    if (column_map.containsKey(board[j][i])) {
                        return false;
                    } else {
                        column_map.put(board[j][i], 1);
                    }
                }
            }
        }

        /*
         * 每个小方块不重复
         */
        for (int i = 0; i < 9; i += 3) {
            for (int j = 0; j < 9; j += 3) {
                Map<Character, Integer> map = new HashMap<Character, Integer>();

                for (int row = i; row < i + 3; row++) {
                    for (int column = j; column < j + 3; column++) {
                        if (board[row][column] != '.') {
                            if (map.containsKey(board[row][column])) {
                                return false;
                            } else {
                                map.put(board[row][column], 1);
                            }
                        }
                    }
                }

            }

        }

        return true;
    }

    public static void main(String[] args) {
        P36 p = new P36();
        char[][] board = {
                {'5', '3', '.', '7', '.', '.', '.', '.', '.'},
                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
                {'.', '9', '8', '1', '.', '.', '.', '6', '.'},
                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
                {'.', '.', '.', '.', '8', '.', '.', '7', '9'},
        };
        System.out.println(p.isValidSudoku(board));
    }
}
```

## 37.Sudoku Solver
Write a program to solve a Sudoku puzzle by filling the empty cells.

Empty cells are indicated by the character '.'.

You may assume that there will be only one unique solution.



A sudoku puzzle...





...and its solution numbers marked in red.

```
public class P37 {
    // 判断当前位置放这个字符是否合理
    public boolean isValid(char[][] board, int row, int column, char c) {
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == c) {
                return false;
            }
        }

        for (int i = 0; i < 9; i++) {
            if (board[i][column] == c) {
                return false;
            }
        }

        // 这里的位置需要注意一下
        for (int i = row / 3 * 3; i < row / 3 * 3 + 3; i++) {
            for (int j = column / 3 * 3; j < column / 3 * 3 + 3; j++) {
                if (board[i][j] == c) {
                    return false;
                }
            }
        }

        return true;
    }

    public boolean dfs(char[][] board, int row, int column) {
        // 到第九行了，说明前面的都放下了，返回true
        if (row == 9) {
            return true;
        }

        if (board[row][column] == '.') {
            // 为.的地方1到9一个个尝试
            for (char i = '1'; i <= '9'; i++) {
                // 合法
                if (isValid(board, row, column, i)) {
                    board[row][column] = i;
                    // 放这个数，如果之后能放下，返回true，column加一，如果大于8，row加一
                    if (dfs(board, row + (column + 1) / 9, (column + 1) % 9)) {
                        return true;
                    }
                    board[row][column] = '.';
                }
            }
            return false;
        } else {
            column++;
            // column加一，如果大于8，row加一
            return dfs(board, row + column / 9, column % 9);
        }
    }

    public void display(char[][] board) {
        for (char[] t : board) {
            for (char i : t) {
                System.out.print(i + " ");
            }
            System.out.println();
        }
    }

    public void solveSudoku(char[][] board) {
        dfs(board, 0, 0);
    }

    public static void main(String[] args) {
        P37 p = new P37();
        char[][] board = {
                {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
                {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
                {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
                {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
                {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
                {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
                {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
                {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
                {'.', '.', '.', '.', '8', '.', '.', '7', '9'},
        };
        p.solveSudoku(board);
    }
}
```


## 38.Count and Say

The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.

Example 1:

Input: 1
Output: "1"


Example 2:

Input: 4
Output: "1211"

题意:
一开始为1，读作1个1，即11
然后是11，读作2个1，即21
然后21，读作1个2,1个1，即1211
...

```
public class P38 {
    public String countAndSay(int n) {
        StringBuilder rst = new StringBuilder("1");
        int count = 0;

        for (int i = 1; i < n; i++) {
            StringBuilder temp = new StringBuilder();
            for (int j = 0, len = rst.length(); j < len; j++) {
                count = 1;
                // 如果下一个字符和当前字符一样，count和j均加一，可以计算当前字符重复了多少次，并移动到最后一个位置
                while (j < len - 1 && rst.charAt(j) == rst.charAt(j + 1)) {
                    count++;
                    j++;
                }

                temp.append(count);
                temp.append(rst.charAt(j));
            }
            rst = temp;
        }

        return rst.toString();
    }

    public static void main(String[] args) {
        P38 p = new P38();
        System.out.println(p.countAndSay(4));
    }
}
```

## 39.Combination Sum
Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.


For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 

[
  [7],
  [2, 2, 3]
]

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class P39 {
    public void dfs(int[] candidates, List<List<Integer>> rst, int target, int curSum, int validNum, int curPos, List<Integer> list) {
        if (curPos > validNum || curSum > target) {
            return;
        }
        if (curSum == target) {
            List<Integer> temp = new ArrayList<Integer>();
            temp.addAll(list);
            rst.add(temp);
        } else {
            list.add(candidates[curPos]);
            // 取这个数，注意curPos没有加1，因为可能取多次。取一次的话，这次取，下一次不去就等价了
            dfs(candidates, rst, target, curSum + candidates[curPos], validNum, curPos, list);
            list.remove(list.size() - 1);
            // 不取这个数
            dfs(candidates, rst, target, curSum, validNum, curPos + 1, list);
        }
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);
        int validNum = 0;

        // 去重，实际可以不用，这里为了保险一些
        for (int i = 1, len = candidates.length; i < len; i++) {
            if (candidates[i] == candidates[i - 1]) {
                continue;
            } else {
                candidates[++validNum] = candidates[i];
            }
        }

        dfs(candidates, rst, target, 0, validNum, 0, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P39 p = new P39();
        int[] nums = {2, 3, 4, 7};
        List<List<Integer>> rst = p.combinationSum(nums, 7);
        for (List<Integer> list : rst) {
            for (Integer t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```
```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class P39_new {
    /*
     * 时间复杂度O(target * n)
     * target很大，n很小是不划算
     * 思路是类似背包算法，但把结果存起来
     */

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        // 存放target为0到target的结果
        List<List<List<Integer>>> rst = new ArrayList<List<List<Integer>>>();
        // 排序是为了去重
        Arrays.sort(candidates);

        for (int i = 0; i <= target; i++) {
            List<List<Integer>> newRst = new ArrayList<List<Integer>>();
            // 这里因为candidates排了序，所以加了个条件能提前结束
            for (int j = 0, len = candidates.length; j < len && candidates[j] <= i; j++) {
                if (candidates[j] == i) {
                    List<Integer> temp = new ArrayList<Integer>();
                    temp.add(candidates[j]);
                    newRst.add(temp);
                } else {
                    // i - candidates是否有结果，有的话加上candidates[j]就是i的结果
                    // 注意这里的for内容，get去了一层，for又去了一层，所以是List<Integer>
                    for (List<Integer> l : rst.get(i - candidates[j])) {
                        /*
                         * 这里是为了去重，比如2 3 6 7
                         * index 1  2  3  4  5  6  7
                         * rst      2  3 2,2
                         * 到5这里，2,3和3,2会添加两遍，我们让candidates[j] <= l.get(0)时才添加，就只有2,3了
                         * 且rst里的顺序都是从小到大(temp添加的顺序)，这样就不会重复了
                         * 或者下面改成candidates[j] >= l.get(l.size() -1)
                         * temp两个add顺序交换一下
                         */
                        if (candidates[j] <= l.get(0)) {
                            List<Integer> temp = new ArrayList<Integer>();
                            temp.add(candidates[j]);
                            temp.addAll(l);
                            newRst.add(temp);
                        }
                    }
                }
            }

            rst.add(newRst);
        }

        return rst.get(target);
    }

    public static void main(String[] args) {
        P39_new p = new P39_new();
        int[] nums = {2, 3, 6, 7};
        List<List<Integer>> rst = p.combinationSum(nums, 7);
        for (List<Integer> list : rst) {
            for (Integer t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```


## 40.Combination Sum II
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

Each number in C may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.


For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, 
A solution set is: 

[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class P40 {
    /*
     * 时间复杂度O(n^n)
     */

    public void dfs(int[] candidates, List<List<Integer>> rst, int target, int curSum, int len, int curPos, List<Integer> list) {
        if (curSum == target) {
            List<Integer> temp = new ArrayList<Integer>();
            temp.addAll(list);
            rst.add(temp);
        } else if (curPos > len || curSum > target) {
            return;
        } else {
            list.add(candidates[curPos]);
            // 取这个数
            dfs(candidates, rst, target, curSum + candidates[curPos], len, curPos + 1, list);
            list.remove(list.size() - 1);
            // 不取这个数
            dfs(candidates, rst, target, curSum, len, curPos + 1, list);
        }
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);

        dfs(candidates, rst, target, 0, candidates.length - 1, 0, new ArrayList<Integer>());

        // 这里用HashSet去重，有些多余了
        Set<String> set = new HashSet<String>();
        List<List<Integer>> newRst = new ArrayList<List<Integer>>();
        for (List<Integer> list : rst) {
            StringBuilder sb = new StringBuilder();
            for (Integer l : list) {
                sb.append(l + "_");
            }

            if (set.add(sb.toString())) {
                newRst.add(list);
            }
        }

        return newRst;
    }

    public static void main(String[] args) {
        P40 p = new P40();
        int[] nums = {1};
        List<List<Integer>> rst = p.combinationSum2(nums, 1);
        for (List<Integer> list : rst) {
            for (Integer t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```
```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class P40_new {
    public void dfs(int[] candidates, List<List<Integer>> rst, int target, int curSum, int len, int curPos, List<Integer> list) {
        if (curSum == target) {
            rst.add(new ArrayList<Integer>(list));
        } else if (curPos > len || curSum > target) {
            return;
        } else {
            // 计算这个数重复了多少次
            int count = 1;
            for (int i = curPos; i < len; i++) {
                if (candidates[i] == candidates[i + 1]) {
                    count++;
                } else {
                    break;
                }
            }

            // 遍历重复的次数，取一个，取两个...取count个
            for (int i = 1; i <= count; i++) {
                int temp = 0;
                for (int j = 0; j < i; j++) {
                    list.add(candidates[curPos]);
                    temp += candidates[curPos];
                }

                dfs(candidates, rst, target, curSum + temp, len, curPos + count, list);

                for (int j = 0; j < i; j++) {
                    list.remove(list.size() - 1);
                }
            }

            // 注意curPos + count，全不取，可以放到上面，i从0开始就好
            dfs(candidates, rst, target, curSum, len, curPos + count, list);
        }
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);

        dfs(candidates, rst, target, 0, candidates.length - 1, 0, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P40_new p = new P40_new();
        int[] nums = {10, 1, 2, 7, 6, 1, 5};
        List<List<Integer>> rst = p.combinationSum2(nums, 8);
        for (List<Integer> list : rst) {
            for (Integer t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```

