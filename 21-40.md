## 21.Merge Two Sorted Lists
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4

```
public class P21 {
    /*
     * 简单归并，用原来的节点
     */
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode rst = new ListNode(0);
        ListNode head = rst;

        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                rst.next = l1;
                l1 = l1.next;
            } else {
                rst.next = l2;
                l2 = l2.next;
            }

            rst = rst.next;
        }

        rst.next = l1 == null ? l2 : l1;

        return head.next;
    }

    public static void main(String[] args) {
        P21 p = new P21();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(1);
        ListNode node1 = p.new ListNode(2);
        ListNode node2 = p.new ListNode(4);
        ListNode node3 = p.new ListNode(3);
        ListNode node4 = p.new ListNode(4);
        l1.next = node1;
        node1.next = node2;
        l2.next = node3;
        node3.next = node4;

        ListNode l = p.mergeTwoLists(l1, l2);
        while (l != null) {
            System.out.println(l.val);
            l = l.next;
        }
    }
}

```


## 22.Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]


```

import java.util.ArrayList;
import java.util.List;

public class P22 {
    /*
     * 简单搜索
     */

    public void dfs(int n, int leftParentheseNum, int rightParentheseNum, StringBuilder str, List<String> rst) {
        if (n == leftParentheseNum && n == rightParentheseNum) {
            rst.add(str.toString());
            return;
        } else {
            // 左括号不够
            if (leftParentheseNum <= n) {
                str.append('(');
                dfs(n, leftParentheseNum + 1, rightParentheseNum, str, rst);
                str.deleteCharAt(leftParentheseNum + rightParentheseNum);
            }

            // 右括号还小于左括号
            if (leftParentheseNum > rightParentheseNum) {
                str.append(')');
                dfs(n, leftParentheseNum, rightParentheseNum + 1, str, rst);
                str.deleteCharAt(leftParentheseNum + rightParentheseNum);
            }
        }
    }

    public List<String> generateParenthesis(int n) {
        List<String> rst = new ArrayList<String>();
        if (n == 0) {
            return rst;
        }
        dfs(n, 0, 0, new StringBuilder(), rst);

        return rst;
    }

    public static void main(String[] args) {
        P22 p = new P22();
        List<String> list = p.generateParenthesis(3);
        for (String s : list) {
            System.out.println(s);
        }
    }
}

```

## 23.Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
```
import java.util.Comparator;
import java.util.PriorityQueue;

public class P23 {
    /*
     * 暴力求解时间复杂度为O(kn)，k为lists.length，n为总节点数。每次遍历k次，可以得到一个节点，总共n个节点
     * 用优先队列(堆)，时间复杂度为O(nlogk)，每次得到一个节点只需要logk次
     */
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }

        // 优先队列的使用
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(new Comparator<ListNode>() {

            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val) {
                    return -1;
                } else if (o1.val > o2.val) {
                    return 1;
                }
                return 0;
            }
        });

        ListNode head = new ListNode(0);
        ListNode rst = head;

        for (ListNode l : lists) {
            if (l != null) {
                queue.add(l);
            }
        }

        // 每次添加最小的元素，如果它的下一个元素不为null，则再添加进队列
        while (!queue.isEmpty()) {
            rst.next = queue.poll();
            rst = rst.next;
            if (rst.next != null) {
                queue.add(rst.next);
            }
        }

        return head.next;
    }

    public static void main(String[] args) {
        P23 p = new P23();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        ListNode l5 = p.new ListNode(5);
        l1.next = l4;
        l2.next = l5;

        ListNode[] lists = {l1, l2, l3};
        ListNode rst = p.mergeKLists(lists);

        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```


## 24.Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head.

For example,
Given 1->2->3->4, you should return the list as 2->1->4->3.

Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

```
public class P24 {
    /*
     * 1 -> 2 -> 3 -> 4
     * 2 -> 1 -> 4 -> 3
     */

    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode rst = new ListNode(0);
        ListNode temp = rst;

        ListNode left = head;
        ListNode right = head.next;

        /*
         * left和right指向相邻两个节点
         * temp先指向right，再指向left
         * 记得right结束后往后移，否则会丢失位置
         * left.next要指向right，不然会有环，即最后两个节点相互指向
         */
        while (right != null) {
            temp.next = right;
            temp = temp.next;
            right = right.next;
            temp.next = left;
            temp = temp.next;
            left.next = right;
            if (right != null) {
                left = right;
                right = left.next;
            }
        }

        return rst.next;
    }

    public static void main(String[] args) {
        P24 p = new P24();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;

        ListNode rst = p.swapPairs(l1);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```
```
public class P24_new {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    /*
     * 简洁的递归写法，但占用空间较大
     */
    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        /*
         * 假设swapPairs能翻转head及之后的节点，并返回翻转之后的头节点
         */
        ListNode node = head.next;
        head.next = swapPairs(head.next.next);
        node.next = head;

        return node;
    }

    public static void main(String[] args) {
        P24_new p = new P24_new();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;

        ListNode rst = p.swapPairs(l1);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}
```


## 25.Reverse Nodes in k-Group
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

You may not alter the values in the nodes, only nodes itself may be changed.
Only constant memory is allowed. 一定内存，所以不好用递归，不然会简单挺多
For example,
Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

```
public class P25 {
    class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public ListNode reverseKGroup(ListNode head, int k) {
        int len = 0;
        ListNode temp = head;
        // 计算链表长度
        while (temp != null) {
            len++;
            temp = temp.next;
        }

        // k = 1， 或者链表长度不到k，直接返回
        if (k <= 1 || len < k) {
            return head;
        }

        ListNode rst = new ListNode(0);
        // 上次前面翻转后的最后一个节点，要指向后面翻转后的第一个节点，专门用一个变量记录一下
        ListNode lastTimeLastNode = rst;

        ListNode curPos = head;
        ListNode pre, cur, next;

        for (int i = k; i <= len; i += k) {
            pre = curPos;
            cur = pre.next;
            next = cur.next;
            // k - 1次，把k - 1个next指向前面节点
            for (int j = 1; j < k; j++) {
                cur.next = pre;
                pre = cur;
                cur = next;
                if (next != null) {
                    next = next.next;
                }
            }

            /* 上面循环结束后的结果
             *  1 -> 2 -> 3 -> 4 -> 5
             *  p    c    n
             *
             *  1-><-2    3 -> 4 -> 5
             *       p    c    n
             *
             *  1-><-2 <- 3    4 -> 5
             *            p    c    n
             */
            // 上次的最后一个节点的next指向本次翻转后的第一个节点3
            lastTimeLastNode.next = pre;
            // lastTimeLastNode变成1
            lastTimeLastNode = curPos;
            // 本轮翻转后的节点的最后一个（1），指向下一次的第一个（4）（后面反转后可能不是第一个节点，但如果后面没有k个节点，则是，这样能保证）
            curPos.next = cur;
            // 准备下一次
            curPos = cur;
        }

        return rst.next;
    }

    public static void main(String[] args) {
        P25 p = new P25();
        ListNode l1 = p.new ListNode(1);
        ListNode l2 = p.new ListNode(2);
        ListNode l3 = p.new ListNode(3);
        ListNode l4 = p.new ListNode(4);
        ListNode l5 = p.new ListNode(5);
        l1.next = l2;
        l2.next = l3;
        l3.next = l4;
        l4.next = l5;

        ListNode rst = p.reverseKGroup(l1, 3);
        while (rst != null) {
            System.out.println(rst.val);
            rst = rst.next;
        }
    }
}

```


## 26.Remove Duplicates from Sorted Array
Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the new length.

```
public class P26 {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }

        int pos = 0;
        for (int i = 1, len = nums.length; i < len; i++) {
            // 和前一个数一样，跳过
            if (nums[i] == nums[i - 1]) {
                continue;
            }

            // 否则pos+1等于这个数
            nums[++pos] = nums[i];
        }

        return pos + 1;
    }

    public static void main(String[] args) {
        P26 p = new P26();
        int[] nums = {1, 1, 2};
        System.out.println(p.removeDuplicates(nums));
    }
}
```


## 27.Remove Element
Given an array and a value, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

```

public class P27 {
    public int removeElement(int[] nums, int val) {
        // 等于val跳过，否则pos位置换做它
        int pos = 0;
        for (int i = 0, len = nums.length; i < len; i++) {
            if (nums[i] != val) {
                nums[pos++] = nums[i];
            }
        }

        return pos;
    }

    public static void main(String[] args) {
        P27 p = new P27();
        int[] nums = {3, 2, 2, 3};
        System.out.println(p.removeElement(nums, 3));
    }
}
```


## 28.Implement strStr()
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2


Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1

```
public class P28 {
    /*
     * KMP匹配
     */

    public int[] getNext(String s) {
        int len = s.length();
        int[] next = new int[len + 1];
        next[0] = -1;
        int k = -1, j = 0;

        while (j < len) {
            if (k == -1 || s.charAt(j) == s.charAt(k)) {
                k++;
                j++;
                next[j] = k;
            } else {
                k = next[k];
            }
        }

        return next;
    }

    public int strStr(String haystack, String needle) {
        int[] next = getNext(needle);
        int hLen = haystack.length();
        int nLen = needle.length();

        int i = 0, j = 0;
        while (i < hLen && j < nLen) {
            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }

        if (j == nLen) {
            return i - nLen;
        } else {
            return -1;
        }
    }

    public static void main(String[] args) {
        P28 p = new P28();
        System.out.println(p.strStr("abaaa", "aab"));
    }
}
```


## 29.Divide Two Integers	
Divide two integers without using multiplication, division and mod operator.

If it is overflow, return MAX_INT.

```
public class P29 {

    public long dfs(long dividend, long divisor) {
        if (dividend < divisor) {
            return 0;
        }

        long rst = 1, temp = divisor;
        /*
         * 每次加倍，一直到不能加为止
         */
        while ((dividend >> 1) >= temp) {
            temp = temp + temp;
            rst = rst + rst;
        }

        return rst + dfs(dividend - temp, divisor);
    }

    public int divide(int dividend, int divisor) {
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        } else if (divisor == 1) {
            return dividend;
        }

        /*
         * 都转成正数，加个符号位
         */
        int sign = 1;
        if ((dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0)) {
            sign = -1;
        }

        long dividend_ = (long) dividend;
        long divisor_ = (long) divisor;

        /*
         * 如果是Integer.MIN_VALUE，abs无效，所以干脆用long
         */
        dividend_ = Math.abs(dividend_);
        divisor_ = Math.abs(divisor_);

        long rst = dfs(dividend_, divisor_);

        if (sign == -1) {
            rst = 0 - rst;
        }

        return (int) rst;
    }

    public static void main(String[] args) {
        P29 p = new P29();
        System.out.println(p.divide(-2147483648, 2));
    }
}
```


## 30.Substring with Concatenation of All Words
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

For example, given:
s: "barfoothefoobarman"
words: ["foo", "bar"]

You should return the indices: [0,9].
(order does not matter).

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class P30 {
    /*
     * 时间复杂度为O(kn)，n为s长度，k为words长度
     * 因为words的长度固定，每次截取相同的长度
     * 用hashMap判断是否完全匹配
     */

    public List<Integer> findSubstring(String s, String[] words) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        List<Integer> rst = new ArrayList<Integer>();

        // words为空，或者s的长度小于每个单词的长度*单词数(总单词长度)
        if (words.length == 0 || words[0].length() * words.length > s.length()) {
            return rst;
        }

        // 将words里的单词加入map
        for (int i = 0, len = words.length; i < len; i++) {
            if (map.containsKey(words[i])) {
                map.put(words[i], map.get(words[i]) + 1);
            } else {
                map.put(words[i], 1);
            }
        }

        int eachWordLen = words[0].length();
        int totalWordsLen = eachWordLen * words.length;
        boolean isAResult = true;
        String str = "";
        Map<String, Integer> curMap = new HashMap<String, Integer>();

        // 遍历s
        for (int i = 0, sLen = s.length(); i <= sLen - totalWordsLen; i++) {
            curMap.clear();
            isAResult = true;
            // 每次截取s中eachWordLen的单词
            for (int j = i; j < i + totalWordsLen; j += eachWordLen) {
                str = s.substring(j, j + eachWordLen);
                // 在map中，则加入curMap
                if (map.containsKey(str)) {
                    if (curMap.containsKey(str)) {
                        // 比map中多了，不符合条件
                        if (curMap.get(str) >= map.get(str)) {
                            isAResult = false;
                            break;
                        }
                        curMap.put(str, curMap.get(str) + 1);
                    } else {
                        curMap.put(str, 1);
                    }
                } else {
                    isAResult = false;
                    break;
                }
            }

            if (isAResult) {
                rst.add(i);
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P30 p = new P30();
        String[] words = {"foo", "bar"};
        List<Integer> rst = p.findSubstring("foobarffbarfoo", words);

        for (Integer t : rst) {
            System.out.println(t);
        }
    }
}

```


## 31.Next Permutation
## 32.Longest Valid Parentheses
## 33.Search in Rotated Sorted Array
## 34.Find First and Last Position of Element in Sorted Array	
## 35.Search Insert Position
## 36.Valid Sudoku
## 37.Sudoku Solver
## 38.Count and Say
## 39.Combination Sum
## 40.Combination Sum II
