## 41.First Missing Positive
Given an unsorted integer array, find the first missing positive integer.

For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.
```
public class P41 {
    /*
     * nums长度为n，最多能表示1到n，最大返回的数是n+1
     * 将数放到它们对应的下表位置，再扫一遍
     * O(n)时间，O(1)额外空间
     */

    public int firstMissingPositive(int[] nums) {
        // 位置i保存整数i + 1
        for (int i = 0, len = nums.length; i < len; i++) {
            // 当前位置数小于等于0，大于n，或是正确的位置，则跳过
            if (nums[i] <= 0 || nums[i] > len || nums[i] == i + 1) {
                continue;
            } else if (nums[nums[i] - 1] != nums[i]) {
                // 上面需要判断一下交换过去的位置是否已经正确，如果不判断，比如1,1会死循环
                swap(nums, i, nums[i] - 1);
                // i--是因为交换过来到i位置的数可能是后面的，不减的话就跳过了它
                i--;
            }
        }

        for (int i = 0, len = nums.length; i < len; i++) {
            if (i + 1 != nums[i]) {
                return i + 1;
            }
        }

        return nums.length + 1;
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public static void main(String[] args) {
        P41 p = new P41();
        int[] nums = {3, 4, -1, 1};
        System.out.println(p.firstMissingPositive(nums));
    }
}
```


## 42.Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.



The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image!

```
public class P42 {
    /*
     * brute force
     * O(n^2)时间，O(1)空间
     * 思路：每次计算当前位置上面放的水，加上它
     * 当前位置上面能放的水，等于左右边最大的值中较小的那个，再减去当前位置高度
     */

    public int trap(int[] height) {
        int rst = 0;
        for (int i = 1, len = height.length; i < len - 1; i++) {
            int leftMax = 0, rightMax = 0;

            // 左边最大值
            for (int j = 0; j <= i; j++) {
                leftMax = Math.max(leftMax, height[j]);
            }

            // 右边最大值
            for (int j = i; j < len; j++) {
                rightMax = Math.max(rightMax, height[j]);
            }

            // 加上当前位置上面能放的水
            rst += Math.min(leftMax, rightMax) - height[i];
        }

        return rst;
    }

    public static void main(String[] args) {
        P42 p = new P42();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
public class P42_new {
    /*
     * dp
     * O(n)时间，O(n)空间
     * 思路：在brute force里，每次求左右两边的最大值需要重复计算，这里把它保存下来
     * dp[i] = max(dp[i - 1], height[i])
     */

    public int trap(int[] height) {
        int rst = 0, size = height.length;
        if (size < 2) {
            return 0;
        }

        int[] leftMax = new int[size];
        int[] rightMax = new int[size];
        leftMax[0] = height[0];
        rightMax[size - 1] = height[size - 1];

        // 求左右两边最大值
        for (int i = 1; i < size - 1; i++) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
            rightMax[size - i - 1] = Math.max(rightMax[size - i], height[size - i - 1]);
        }

        // 加上当前位置上面能放的最大水
        for (int i = 1; i < size - 1; i++) {
            rst += Math.min(leftMax[i], rightMax[i]) - height[i];
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new p = new P42_new();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
import java.util.Stack;

public class P42_new_new {
    /*
     * stack, O(n)时间，O(n)空间
     * 思路：和前两种竖着计算不同，这是横着计算面积，再相加
     */

    public int trap(int[] height) {
        int rst = 0, size = height.length, temp, dis, h;
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = 0; i < size; i++) {
            // 栈里存放的元素会从大到小排列
            // 当前位置比栈顶位置更高，说明一定有一条横的面积(除非空栈)
            // 不断出栈，直到栈顶元素比当前位置高
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                // 记录一下底下的高度
                temp = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }

                // 宽度
                dis = i - stack.peek() - 1;
                // 高度
                h = Math.min(height[i], height[stack.peek()]) - height[temp];
                // 加上面积
                rst += dis * h;
            }

            stack.push(i);
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new_new p = new P42_new_new();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
public class P42_new_new_new {
    /*
     * 双指针，O(n)时间，O(1)空间
     * 思路：左右双指针，并记录左右扫过的最大值
     * 双指针中对应位置高度较小的那方移动
     * 原因是比如1 0 3，答案是1，是从左边移动过来计算
     * 如果小于记录的最大值，则赋值，否则加上最大值减去当前位置高度，竖着计算面积

     * 下面代码写的不好理解，其实每次移动小的那个，暗示了一个条件，移动的比如left，则height[right]一定大于leftMax，否则当赋值给leftMax那次比较，移动的就会是right
     * 下面的代码会好理解一些，直接比较leftMax和rightMax
     */

    public int trap(int[] height) {
        int rst = 0, leftMax = 0, rightMax = 0, left = 0, right = height.length - 1;
        while (left < right) {
            // 移动高度小的那方
            if (height[left] < height[right]) {
                // 记录的最大值小于当前位置，则赋值
                if (leftMax <= height[left]) {
                    leftMax = height[left];
                } else {
                    // 否则加上记录的最大值减去当面高度，即面积
                    rst += leftMax - height[left];
                }

                left++;
            } else {
                if (rightMax <= height[right]) {
                    rightMax = height[right];
                } else {
                    rst += rightMax - height[right];
                }

                right--;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new_new_new  p = new P42_new_new_new ();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```



## 43.Multiply Strings

Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
Note:

The length of both num1 and num2 is < 110.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.

```
public class P43 {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }

        StringBuilder rst = new StringBuilder();
        int carryIn = 0, curNum = 0, temp, rstPos;

        for (int i = 0, len = num2.length(); i < len; i++) {
            curNum = num2.charAt(i) - '0';
            carryIn = 0;
            StringBuilder timesRst = new StringBuilder();

            // 乘单个数字
            for (int j = num1.length() - 1; j >= 0; j--) {
                temp = (num1.charAt(j) - '0') * curNum + carryIn;
                timesRst.insert(0, temp % 10);
                carryIn = temp / 10;
            }

            // 最高位进位
            if (carryIn != 0) {
                timesRst.insert(0, carryIn);
            }

            // 相加
            rstPos = rst.length() - 1;
            carryIn = 0;
            for (int j = timesRst.length() - 1; j >= 0 || rstPos >= 0; j--) {
                // 两个都还有数字
                if (rstPos >= 0 && j >= 0) {
                    temp = rst.charAt(rstPos) - '0' + timesRst.charAt(j) - '0' + carryIn;
                    rst.setCharAt(rstPos, (char) (temp % 10 + '0'));
                    carryIn = temp / 10;
                    rstPos--;
                } else if (rstPos < 0) {
                    // rst没有数字了
                    temp = timesRst.charAt(j) - '0' + carryIn;
                    rst.insert(0, temp % 10);
                    carryIn = temp / 10;
                } else {
                    // timesRst没有数字了
                    if (carryIn == 0) {
                        break;
                    } else {
                        temp = rst.charAt(rstPos) - '0' + carryIn;
                        rst.setCharAt(rstPos, (char) (temp % 10 + '0'));
                        carryIn = temp / 10;
                        rstPos--;
                    }
                }
            }

            if (carryIn != 0) {
                rst.insert(0, carryIn);
            }

            // 因为是左边开始乘的，每次都要左移一位
            if (i != len - 1) {
                rst.append('0');
            }
        }

        return rst.toString();
    }

    public static void main(String[] args) {
        P43 p = new P43();
        System.out.println(p.multiply("123", "456"));
    }
}
```

```
public class P43_new {
    public String multiply(String num1, String num2) {
        int[] rst = new int[num1.length() + num2.length()];
        int temp;

        // num1[i] * num2[j] 只会放在i + j和i + j + 1
        for (int i = num1.length() - 1; i >= 0; i--) {
            for (int j = num2.length() - 1; j >= 0; j--) {
                temp = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                rst[i + j + 1] += temp % 10;
                rst[i + j] += temp / 10;
            }
        }

        StringBuilder sb = new StringBuilder();
        int pos = rst.length - 1, carryIn = 0;
        // 找到第一个不为0的位置
        for (int i = 0, len = rst.length; i < len; i++) {
            if (rst[i] != 0) {
                pos = i;
                break;
            }
        }

        // 可能会有进位
        for (int i = rst.length - 1; i >= pos; i--) {
            sb.insert(0, (char) ((rst[i] + carryIn) % 10 + '0'));
            carryIn = (rst[i] + carryIn) / 10;
        }

        if (carryIn != 0) {
            sb.insert(0, (char) (carryIn + '0'));
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        P43_new p = new P43_new();
        System.out.println(p.multiply("123", "456"));
    }
}
```

## 44.Wildcard Matching	
Implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

```

public class P44 {
    /*
     * 时间复杂度O(2^n)
     * "aaabbbaabaaaaababaabaaabbabbbbbbbbaabababbabbbaaaaba"
     * "a*******b"
     * 会超时
     */

    public boolean dfs(String s, int sPos, int sLen, String p, int pPos, int pLen) {
        if (pPos >= pLen) {
            return sPos >= sLen;
        }

        if (sPos < sLen && (s.charAt(sPos) == p.charAt(pPos) || p.charAt(pPos) == '?')) {
            // 各后移一位
            return dfs(s, sPos + 1, sLen, p, pPos + 1, pLen);
        } else if (p.charAt(pPos) == '*') {
            if (sPos < sLen) {
                // s没有匹配完，*不匹配 || * 匹配一个
                return dfs(s, sPos, sLen, p, pPos + 1, pLen)
                        || dfs(s, sPos + 1, sLen, p, pPos, pLen);
            } else {
                // s匹配完了(例如aa, aa***), *不匹配
                return dfs(s, sPos, sLen, p, pPos + 1, pLen);
            }
        } else {
            return false;
        }
    }

    public boolean isMatch(String s, String p) {
        return dfs(s, 0, s.length(), p, 0, p.length());
    }

    public static void main(String[] args) {
        P44 p = new P44();
        System.out.println(p.isMatch("aab", "a*b"));
    }
}
```
```
public class P44_new {
    /*
     * dp, 时间复杂度O(nm)
     * 状态转移方程
     * dp[i][j]表示s前i个和p前j个是否匹配
     * dp[i][j] = dp[i - 1][j - 1]   if s[i] == p[j] || p[j] == '?'
     * dp[i][j] = dp[i][j - 1] || dp[i - 1][j]   if p[j] == '*'
     * else dp[i][j] = false
     */

    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];

        // 初始话， 比如aa, *是匹配的
        dp[0][0] = true;
        for (int i = 1, pLen = p.length(); i <= pLen; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = true;
            } else {
                break;
            }
        }

        for (int i = 1, sLen = s.length(); i <= sLen; i++) {
            for (int j = 1, pLen = p.length(); j <= pLen; j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[s.length()][p.length()];
    }

    public static void main(String[] args) {
        P44_new p = new P44_new();
        System.out.println(p.isMatch("aa", "*"));
    }
}
```


## 45.Jump Game II
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:
You can assume that you can always reach the last index.

```
public class P45 {
    /*
     * 贪心，O(n)时间
     * 每次选当前跳的最远距离内能跳的最远距离
     */

    public int jump(int[] nums) {
        int nextMaxIndex = 0, curMaxIndex = -1, rst = 0;

        for (int i = 0, len = nums.length; i < len; i++) {
            // 在当前位置能跳的最远距离内，判断下一次能跳的最远距离
            if (i <= curMaxIndex) {
                if (i + nums[i] > nextMaxIndex) {
                    nextMaxIndex = i + nums[i];
                }
            } else {
                // 下一跳， 如果能跳到最后，直接返回
                curMaxIndex = nextMaxIndex;
                if (curMaxIndex >= len - 1) {
                    return rst;
                }
                rst++;
                // 这里需要i--，因为刚好>curMaxIndex这个位置能跳的最远距离没有计算
                i--;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P45 p = new P45();
        int[] nums = {2, 3, 1, 1, 4};
        System.out.println(p.jump(nums));
    }
}
```


## 46.Permutations
Given a collection of distinct numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:

[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```
import java.util.ArrayList;
import java.util.List;

public class P46 {
    /*
     * 递归，O(n!)时间
     * 假设dfs能排列curPos到len，每次把curPos换个数字，然后自动排列后面的
     */

    public void dfs(List<List<Integer>> rst, int[] nums, int curPos, int len, List<Integer> list) {
        if (curPos == len - 1) {
            list.add(nums[curPos]);
            rst.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        } else {
            for (int i = curPos; i < len; i++) {
                swap(nums, curPos, i);
                list.add(nums[curPos]);
                dfs(rst, nums, curPos + 1, len, list);
                list.remove(list.size() - 1);
                // 实际是可加可不加，加上后结果会比较整齐，但答案比较需要按顺序来，所以加上了
                swap(nums, curPos, i);
            }
        }
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        dfs(rst, nums, 0, nums.length, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P46 p = new P46();
        int[] nums = {1, 2, 3};
        List<List<Integer>> rst = p.permute(nums);
        for (List<Integer> list : rst) {
            for (int t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```


## 47.Permutations II
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:

[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class P47 {
    public void dfs(List<List<Integer>> rst, int[] nums, int curPos, int len, List<Integer> list) {
        if (curPos == len - 1) {
            list.add(nums[curPos]);
            rst.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        } else {
            Set<Integer> hasBeenInFirst = new HashSet<Integer>();
            for (int i = curPos; i < len; i++) {
                // 相同的数字只能出现在第一位一次
                if (!hasBeenInFirst.contains(nums[i])) {
                    hasBeenInFirst.add(nums[i]);
                    swap(nums, curPos, i);
                    list.add(nums[curPos]);
                    dfs(rst, nums, curPos + 1, len, list);
                    list.remove(list.size() - 1);
                    swap(nums, curPos, i);
                }
            }
        }
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        dfs(rst, nums, 0, nums.length, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P47 p = new P47();
        int[] nums = {1, 1, 1, 2, 3};
        List<List<Integer>> rst = p.permuteUnique(nums);
        for (List<Integer> list : rst) {
            for (int t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```



## 48.Rotate Image

You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]


```
public class P48 {
    /*
     * 变换规律:
     * 列 -> 行
     * 行 -> (n - 行 + 1)列
     */
    public void rotate(int[][] matrix) {
        int len = matrix.length;
        int swapRow, swapColumn, temp;

        for (int row = 0; row < len / 2; row++) {
            for (int column = row; column < len - row - 1; column++) {
                // 四个数交换
                /*
                 * {11, 12, 13, 14},
                 * {21, 22, 23, 24},
                 * {31, 32, 33, 34},
                 * {41, 42, 43, 44}
                 *
                 * 11，14交换，14， 44交换，44， 41交换
                 */
                swapRow = column;
                swapColumn = len - row - 1;
                swap(matrix, row, column, swapRow, swapColumn);

                temp = swapRow;
                swapRow = swapColumn;
                swapColumn = len - temp - 1;
                swap(matrix, row, column, swapRow, swapColumn);

                temp = swapRow;
                swapRow = swapColumn;
                swapColumn = len - temp - 1;
                swap(matrix, row, column, swapRow, swapColumn);
            }
        }

        for (int[] row : matrix) {
            for (int t : row) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }

    public void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }

    public static void main(String[] args) {
        P48 p = new P48();
        int[][] matrix = {
                {11, 12, 13, 14},
                {21, 22, 23, 24},
                {31, 32, 33, 34},
                {41, 42, 43, 44}
        };

        p.rotate(matrix);
    }
}
```

```
public class P48_new {
    /*
     * 变换规律:
     * 列 -> 行
     * 行 -> (n - 行 + 1)列
     *
     * 列变行，用转置
     * 行变(n - 行 + 1)列，转置后，行变成了列，列再左右对称交换一下
     */

    public void rotate(int[][] matrix) {
        int len = matrix.length;

        // 转置，行列互换
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                swap(matrix, i, j, j, i);
            }
        }

        // 列对称交换
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len / 2; j++) {
                swap(matrix, i, j, i, len - j - 1);
            }
        }

        for (int[] row : matrix) {
            for (int t : row) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }

    public void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }

    public static void main(String[] args) {
        P48_new p = new P48_new();
        int[][] matrix = {
                {11, 12, 13, 14},
                {21, 22, 23, 24},
                {31, 32, 33, 34},
                {41, 42, 43, 44}
        };

        p.rotate(matrix);
    }
}
```


## 49.Group Anagrams

Given an array of strings, group anagrams together.

For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
Return:

[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]


Note: All inputs will be in lower-case.

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class P49 {
    /*
     * 时间复杂度O(nk)，n为strs数组长度，k为字符串最长长度
     * 思路：统计字符串中每个字符出现次数，编码成字符串，加入哈希表，如果一样说明是同一类型
     * 编码可以用其他方法，比如素数，0到25字符对应一个素数，是这个数，乘上这个数，编码成了整数
     * 另一种思路，不统计字符出现次数，把字符串转成字符数组，排序，再加入哈希表，时间复杂度O(nklogk)
     */

    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> rst = new ArrayList<List<String>>();
        Map<String, Integer> map = new HashMap<String, Integer>();
        String str;

        for (int i = 0, len = strs.length; i < len; i++) {
            int[] temp = new int[26];
            str = strs[i];
            // 统计字符出现次数
            for (int j = 0, strLen = str.length(); j < strLen; j++) {
                temp[str.charAt(j) - 'a']++;
            }

            // 编码
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                sb.append(temp[j] + '-');
            }

            // 如果已经在map中， 加入rst相应位置，否则加入map和rst
            if (map.containsKey(sb.toString())) {
                rst.get(map.get(sb.toString())).add(str);
            } else {
                map.put(sb.toString(), rst.size());
                List<String> list = new ArrayList<String>();
                list.add(str);
                rst.add(list);
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P49 p = new P49();
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        List<List<String>> rst = p.groupAnagrams(strs);
        for (List<String> list : rst) {
            for (String t : list) {
                System.out.print(t + " ");
            }

            System.out.println();
        }
    }
}
```

## 50.Pow(x, n)

Implement pow(x, n).

Example 1:

Input: 2.00000, 10
Output: 1024.00000


Example 2:

Input: 2.10000, 3
Output: 9.26100

```
public class P50 {
    /*
     * 快速幂，注意一下特殊情况就好
     * O(logn)时间，O(1)空间
     * 也可以用递归，每次分一半，O(logn)时间，O(logn)空间
     */

    public double myPow(double x, int n) {
        // 注意n为负数的情况
        boolean nIsNegative = n < 0;
        boolean nIsMaxNegative = n == Integer.MIN_VALUE;
        double xTemp = x;

        // 注意n为Integer.MIN_VALUE时，abs会溢出
        n = nIsMaxNegative ? Integer.MAX_VALUE : Math.abs(n);
        double rst = 1.0;
        // 快速幂
        while (n != 0) {
            if ((n & 1) == 1) {
                rst *= x;
            }

            n >>= 1;
            x *= x;
        }

        if (nIsMaxNegative) {
            rst *= xTemp;
        }

        return nIsNegative ? 1.0 / rst : rst;
    }

    public static void main(String[] args) {
        P50 p = new P50();
        System.out.println(p.myPow(-1, -2147483648));
    }
}
```

## 51.N-Queens
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.



Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

For example,
There exist two distinct solutions to the 4-queens puzzle:

[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]

```
import java.util.ArrayList;
import java.util.List;

public class P51 {
    public void dfs(int n, int curPos, List<Integer> oneRst, List<List<Integer>> rst) {
        if (curPos == n) {
            List<Integer> temp = new ArrayList<Integer>(oneRst);
            rst.add(temp);
        } else {
            for (int i = 0; i < n; i++) {
                if (canPlace(i, oneRst)) {
                    oneRst.add(i);
                    dfs(n, curPos + 1, oneRst, rst);
                    oneRst.remove(oneRst.size() - 1);
                }
            }
        }
    }

    public boolean canPlace(int column, List<Integer> oneRst) {
        int row = oneRst.size();
        for (int i = 0, len = oneRst.size(); i < len; i++) {
            // 已经是不同行了，只要同一列，两个对角不能互相攻击
            if (column == oneRst.get(i) || i + oneRst.get(i) == row + column || i - oneRst.get(i) == row - column) {
                return false;
            }
        }

        return true;
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> rst = new ArrayList<List<String>>();
        List<List<Integer>> tempRst = new ArrayList<List<Integer>>();

        dfs(n, 0, new ArrayList<Integer>(), tempRst);

        // 先求出具体解，再转成字符串
        for (List<Integer> list : tempRst) {
            List<String> oneRst = new ArrayList<String>();
            for (int t : list) {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < n; i++) {
                    if (i == t) {
                        sb.append('Q');
                    } else {
                        sb.append('.');
                    }
                }
                oneRst.add(sb.toString());
            }

            rst.add(oneRst);
        }

        return rst;
    }

    public static void main(String[] args) {
        P51 p = new P51();
        List<List<String>> rst = p.solveNQueens(4);
        for (List<String> list : rst) {
            for (String str : list) {
                System.out.println(str);
            }
            System.out.println();
        }
    }
}
```


## 52.N-Queens II	
Follow up for N-Queens problem.

Now, instead outputting board configurations, return the total number of distinct solutions.


```
import java.util.ArrayList;
import java.util.List;

public class P52 {
    // 同51做法一样

    public void dfs(int n, int curPos, List<Integer> oneRst, List<List<Integer>> rst) {
        if (curPos == n) {
            List<Integer> temp = new ArrayList<Integer>(oneRst);
            if (temp.size() != 0) {
                rst.add(temp);
            }
        } else {
            for (int i = 0; i < n; i++) {
                if (canPlace(i, oneRst)) {
                    oneRst.add(i);
                    dfs(n, curPos + 1, oneRst, rst);
                    oneRst.remove(oneRst.size() - 1);
                }
            }
        }
    }

    public boolean canPlace(int column, List<Integer> oneRst) {
        int row = oneRst.size();
        for (int i = 0, len = oneRst.size(); i < len; i++) {
            if (column == oneRst.get(i) || i + oneRst.get(i) == row + column || i - oneRst.get(i) == row - column) {
                return false;
            }
        }

        return true;
    }

    public int totalNQueens(int n) {
        List<List<Integer>> tempRst = new ArrayList<List<Integer>>();

        dfs(n, 0, new ArrayList<Integer>(), tempRst);

        return tempRst.size();
    }

    public static void main(String[] args) {
        P52 p = new P52();
        System.out.println(p.totalNQueens(4));
    }
}
```


## 53.Maximum Subarray	
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

click to show more practice.

More practice:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

```
public class P53 {
    /*
     * 动态规划，O(n)时间，O(n)空间
     * dp[i]表示以第i个数结尾的最大连续子数组和
     * dp[i] = max(dp[i - 1] + nums[i - 1], nums[i - 1])
     * 或者写成
     * dp[i] = dp[i - 1] + nums[i - 1]    if dp[i - 1] > 0
     * dp[i] = nums[i - 1]                if dp[i - 1] <= 0
     */

    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length + 1];
        int rst = Integer.MIN_VALUE;
        for (int i = 1, len = nums.length; i <= len; i++) {
            // 如果可以不取的话，把后面的nums[i - 1]改成0即可
            dp[i] = Math.max(dp[i - 1] + nums[i - 1], nums[i - 1]);
            if (dp[i] > rst) {
                rst = dp[i];
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P53 p = new P53();
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(p.maxSubArray(nums));
    }
}
```

```
public class P53_new {
    /*
     * 把之前的动态规划降维，O(n)时间，O(1)空间
     */

    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int rst = Integer.MIN_VALUE;
        int preMax = 0;
        for (int i = 0, len = nums.length; i < len; i++) {
            // 或者写成 preMax = Math.max(preMax + nums[i], nums[i]);
            if (preMax >= 0) {
                preMax = preMax + nums[i];
            } else {
                preMax = nums[i];
            }

            if (preMax > rst) {
                rst = preMax;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P53_new p = new P53_new();
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(p.maxSubArray(nums));
    }
}
```


## 54.Spiral Matrix	
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
You should return [1,2,3,6,9,8,7,4,5].

```
import java.util.ArrayList;
import java.util.List;

public class P54 {
    /*
     * 模拟
     */

    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> rst = new ArrayList<Integer>();
        if (matrix.length == 0) {
            return rst;
        }

        int rowBegin = 0, rowEnd = matrix.length - 1;
        int columnBegin = 0, columnEnd = matrix[0].length - 1;
        int i;

        // 四个方向转
        while (rowBegin <= rowEnd && columnBegin <= columnEnd) {
            for (i = columnBegin; i <= columnEnd; i++) {
                rst.add(matrix[rowBegin][i]);
            }
            rowBegin++;

            for (i = rowBegin; i <= rowEnd; i++) {
                rst.add(matrix[i][columnEnd]);
            }
            columnEnd--;

            // 因为是矩阵，不是方阵，这里需要判断一下行是否合法
            // 比如 [2, 3]，在右，下之后往左，需要行合法
            if (rowBegin <= rowEnd) {
                for (i = columnEnd; i >= columnBegin; i--) {
                    rst.add(matrix[rowEnd][i]);
                }
                rowEnd--;
            }

            // 判断同上面的解释
            if (columnBegin <= columnEnd) {
                for (i = rowEnd; i >= rowBegin; i--) {
                    rst.add(matrix[i][columnBegin]);
                }
                columnBegin++;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P54 p = new P54();
        int[][] matrix = {
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9}
        };

        List<Integer> rst = p.spiralOrder(matrix);
        for (int t : rst) {
            System.out.print(t + " ");
        }
    }
}
```

## 55.Jump Game	
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.

```
public class P55 {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return true;
        }

        int curPos = 0, maxPos = 0;

        while (curPos <= maxPos) {
            if (nums[curPos] + curPos > maxPos) {
                maxPos = nums[curPos] + curPos;
            }
            curPos++;

            if (maxPos >= len - 1) {
                return true;
            }
        }

        return false;
    }

    public static void main(String[] args) {
        P55 p = new P55();
        int[] nums = {2, 2, 1, 0, 4};
        System.out.println(p.canJump(nums));
    }
}
```


## 56.Merge Intervals	
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Interval {
    int start;
    int end;

    Interval() {
        start = 0;
        end = 0;
    }

    Interval(int s, int e) {
        start = s;
        end = e;
    }
}

public class P56 {
    /*
     * 先按start排序，再判断是否有重合，有则合并，没有则加入到rst
     */

    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> rst = new ArrayList<Interval>();
        if (intervals.size() == 0) {
            return rst;
        }

        Collections.sort(intervals, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return o1.start - o2.start;
            }
        });

        rst.add(intervals.get(0));
        Interval preInterval, curInterval;

        for (int i = 1, len = intervals.size(); i < len; i++) {
            preInterval = rst.get(rst.size() - 1);
            curInterval = intervals.get(i);
            // 没有重合，则加入到rst
            /*
             * 例如    ----
             *            ---
             */

            if (curInterval.start > preInterval.end) {
                rst.add(curInterval);
            } else if (curInterval.end > preInterval.end) {
                // 有重合，且当前end大于之前的end，则合并
                /*
                 *  例如 ----
                 *         ---
                 *  或者 ---
                 *       ---
                 */
                preInterval.end = curInterval.end;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P56 p = new P56();
        Interval t1 = new Interval(1, 3);
        Interval t2 = new Interval(2, 6);
        Interval t3 = new Interval(8, 10);
        Interval t4 = new Interval(15, 18);
        List<Interval> intervals = new ArrayList<Interval>();
        intervals.add(t1);
        intervals.add(t2);
        intervals.add(t3);
        intervals.add(t4);

        List<Interval> rst = p.merge(intervals);
        for (Interval t : rst) {
            System.out.println(t.start + " " + t.end);
        }
    }
}
```


## 57.Insert Interval	
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class P57 {
    static class Interval {
        int start;
        int end;

        Interval() {
            start = 0;
            end = 0;
        }

        Interval(int s, int e) {
            start = s;
            end = e;
        }
    }

    /*
     * 和56做法一样，只是先把newInterval加入到intervals
     */
    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
        List<Interval> rst = new ArrayList<Interval>();
        intervals.add(newInterval);

        Collections.sort(intervals, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return o1.start - o2.start;
            }
        });

        rst.add(intervals.get(0));
        Interval preInterval, curInterval;

        for (int i = 1, len = intervals.size(); i < len; i++) {
            preInterval = rst.get(rst.size() - 1);
            curInterval = intervals.get(i);

            if (curInterval.start > preInterval.end) {
                rst.add(curInterval);
            } else if (curInterval.end > preInterval.end) {
                preInterval.end = curInterval.end;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P57 p = new P57();
        Interval t1 = new Interval(1, 3);
        Interval t2 = new Interval(6, 9);
        Interval t3 = new Interval(2, 5);
        List<Interval> intervals = new ArrayList<Interval>();
        intervals.add(t1);
        intervals.add(t2);

        List<Interval> rst = p.insert(intervals, t3);
        for (Interval t : rst) {
            System.out.println(t.start + " " + t.end);
        }
    }
}
```


## 58.Length of Last Word	
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

Example:

Input: "Hello World"
Output: 5


```
public class P58 {
    public int lengthOfLastWord(String s) {
        int end = s.length() - 1;
        // 去除末尾空格
        while (end >= 0 && s.charAt(end) == ' ') {
            end--;
        }

        int start = end;
        // end往前找到第一个空格，或者到0
        while (start >= 0 && s.charAt(start) != ' ') {
            start--;
        }

        return end - start;
    }

    public static void main(String[] args) {
        P58 p = new P58();
        System.out.println(p.lengthOfLastWord("hello world  "));
    }
}
```


## 59.Spiral Matrix II	

Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

For example,
Given n = 3,

You should return the following matrix:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]

```
public class P59 {
    public int[][] generateMatrix(int n) {
        /*
         * 模拟，右下左上循环
         */
        int[][] rst = new int[n][n];
        int rowBegin = 0, rowEnd = n - 1, columnBegin = 0, columnEnd = n - 1;
        int count = 1;

        while (rowBegin <= rowEnd && columnBegin <= columnEnd) {
            // 右
            for (int i = columnBegin; i <= columnEnd; i++) {
                rst[rowBegin][i] = count;
                count++;
            }
            rowBegin++;

            // 下
            for (int i = rowBegin; i <= rowEnd; i++) {
                rst[i][columnEnd] = count;
                count++;
            }
            columnEnd--;

            // 左
            for (int i = columnEnd; i >= columnBegin; i--) {
                rst[rowEnd][i] = count;
                count++;
            }
            rowEnd--;

            // 上
            for (int i = rowEnd; i >= rowBegin; i--) {
                rst[i][columnBegin] = count;
                count++;
            }
            columnBegin++;
        }

        return rst;
    }

    public static void main(String[] args) {
        P59 p = new P59();
        int[][] rst = p.generateMatrix(3);
        for (int[] arr : rst) {
            for (int t : arr) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```

## 60.Permutation Sequence	

The set [1,2,3,…,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):

"123"
"132"
"213"
"231"
"312"
"321"


Given n and k, return the kth permutation sequence.

Note: Given n will be between 1 and 9 inclusive.

```
import java.util.ArrayList;
import java.util.List;

public class P60 {
    public String getPermutation(int n, int k) {
        StringBuilder rst = new StringBuilder();
        int weight = 1;
        List<Integer> list = new ArrayList<Integer>();

        // 1到n加入到list，计算出weight = (n - 1)!
        for (int i = 1; i < n; i++) {
            weight *= i;
            list.add(i);
        }
        list.add(n);

        int index;
        // k--是将第k个数，变成下边为k，比如n = 3, k = 2, weight = 2, 是第二个数，index应该是0
        k--;
        for (int i = n - 1; i > 0; i--) {
            index = k / weight;
            rst.append(list.get(index));

            // k减去本位有的个数
            k = k - index * weight;
            weight /= i;
            // 删除加入了的数，remove默认是删除下标，(Integer)index删除元素
            list.remove(index);
        }

        // 加入最后一个数，放到上面会除0
        rst.append(list.get(0));

        return rst.toString();
    }

    public static void main(String[] args) {
        P60 p = new P60();
        System.out.println(p.getPermutation(1, 1));
    }
}
```

