## 41.First Missing Positive
Given an unsorted integer array, find the first missing positive integer.

For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space.
```
public class P41 {
    /*
     * nums长度为n，最多能表示1到n，最大返回的数是n+1
     * 将数放到它们对应的下表位置，再扫一遍
     * O(n)时间，O(1)额外空间
     */

    public int firstMissingPositive(int[] nums) {
        // 位置i保存整数i + 1
        for (int i = 0, len = nums.length; i < len; i++) {
            // 当前位置数小于等于0，大于n，或是正确的位置，则跳过
            if (nums[i] <= 0 || nums[i] > len || nums[i] == i + 1) {
                continue;
            } else if (nums[nums[i] - 1] != nums[i]) {
                // 上面需要判断一下交换过去的位置是否已经正确，如果不判断，比如1,1会死循环
                swap(nums, i, nums[i] - 1);
                // i--是因为交换过来到i位置的数可能是后面的，不减的话就跳过了它
                i--;
            }
        }

        for (int i = 0, len = nums.length; i < len; i++) {
            if (i + 1 != nums[i]) {
                return i + 1;
            }
        }

        return nums.length + 1;
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public static void main(String[] args) {
        P41 p = new P41();
        int[] nums = {3, 4, -1, 1};
        System.out.println(p.firstMissingPositive(nums));
    }
}
```


## 42.Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.



The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image!

```
public class P42 {
    /*
     * brute force
     * O(n^2)时间，O(1)空间
     * 思路：每次计算当前位置上面放的水，加上它
     * 当前位置上面能放的水，等于左右边最大的值中较小的那个，再减去当前位置高度
     */

    public int trap(int[] height) {
        int rst = 0;
        for (int i = 1, len = height.length; i < len - 1; i++) {
            int leftMax = 0, rightMax = 0;

            // 左边最大值
            for (int j = 0; j <= i; j++) {
                leftMax = Math.max(leftMax, height[j]);
            }

            // 右边最大值
            for (int j = i; j < len; j++) {
                rightMax = Math.max(rightMax, height[j]);
            }

            // 加上当前位置上面能放的水
            rst += Math.min(leftMax, rightMax) - height[i];
        }

        return rst;
    }

    public static void main(String[] args) {
        P42 p = new P42();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
public class P42_new {
    /*
     * dp
     * O(n)时间，O(n)空间
     * 思路：在brute force里，每次求左右两边的最大值需要重复计算，这里把它保存下来
     * dp[i] = max(dp[i - 1], height[i])
     */

    public int trap(int[] height) {
        int rst = 0, size = height.length;
        if (size < 2) {
            return 0;
        }

        int[] leftMax = new int[size];
        int[] rightMax = new int[size];
        leftMax[0] = height[0];
        rightMax[size - 1] = height[size - 1];

        // 求左右两边最大值
        for (int i = 1; i < size - 1; i++) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
            rightMax[size - i - 1] = Math.max(rightMax[size - i], height[size - i - 1]);
        }

        // 加上当前位置上面能放的最大水
        for (int i = 1; i < size - 1; i++) {
            rst += Math.min(leftMax[i], rightMax[i]) - height[i];
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new p = new P42_new();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
import java.util.Stack;

public class P42_new_new {
    /*
     * stack, O(n)时间，O(n)空间
     * 思路：和前两种竖着计算不同，这是横着计算面积，再相加
     */

    public int trap(int[] height) {
        int rst = 0, size = height.length, temp, dis, h;
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = 0; i < size; i++) {
            // 栈里存放的元素会从大到小排列
            // 当前位置比栈顶位置更高，说明一定有一条横的面积(除非空栈)
            // 不断出栈，直到栈顶元素比当前位置高
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                // 记录一下底下的高度
                temp = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }

                // 宽度
                dis = i - stack.peek() - 1;
                // 高度
                h = Math.min(height[i], height[stack.peek()]) - height[temp];
                // 加上面积
                rst += dis * h;
            }

            stack.push(i);
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new_new p = new P42_new_new();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```
```
public class P42_new_new_new {
    /*
     * 双指针，O(n)时间，O(1)空间
     * 思路：左右双指针，并记录左右扫过的最大值
     * 双指针中对应位置高度较小的那方移动
     * 原因是比如1 0 3，答案是1，是从左边移动过来计算
     * 如果小于记录的最大值，则赋值，否则加上最大值减去当前位置高度，竖着计算面积

     * 下面代码写的不好理解，其实每次移动小的那个，暗示了一个条件，移动的比如left，则height[right]一定大于leftMax，否则当赋值给leftMax那次比较，移动的就会是right
     * 下面的代码会好理解一些，直接比较leftMax和rightMax
     */

    public int trap(int[] height) {
        int rst = 0, leftMax = 0, rightMax = 0, left = 0, right = height.length - 1;
        while (left < right) {
            // 移动高度小的那方
            if (height[left] < height[right]) {
                // 记录的最大值小于当前位置，则赋值
                if (leftMax <= height[left]) {
                    leftMax = height[left];
                } else {
                    // 否则加上记录的最大值减去当面高度，即面积
                    rst += leftMax - height[left];
                }

                left++;
            } else {
                if (rightMax <= height[right]) {
                    rightMax = height[right];
                } else {
                    rst += rightMax - height[right];
                }

                right--;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P42_new_new_new  p = new P42_new_new_new ();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(p.trap(height));
    }
}
```



## 43.Multiply Strings

Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
Note:

The length of both num1 and num2 is < 110.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.

```
public class P43 {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }

        StringBuilder rst = new StringBuilder();
        int carryIn = 0, curNum = 0, temp, rstPos;

        for (int i = 0, len = num2.length(); i < len; i++) {
            curNum = num2.charAt(i) - '0';
            carryIn = 0;
            StringBuilder timesRst = new StringBuilder();

            // 乘单个数字
            for (int j = num1.length() - 1; j >= 0; j--) {
                temp = (num1.charAt(j) - '0') * curNum + carryIn;
                timesRst.insert(0, temp % 10);
                carryIn = temp / 10;
            }

            // 最高位进位
            if (carryIn != 0) {
                timesRst.insert(0, carryIn);
            }

            // 相加
            rstPos = rst.length() - 1;
            carryIn = 0;
            for (int j = timesRst.length() - 1; j >= 0 || rstPos >= 0; j--) {
                // 两个都还有数字
                if (rstPos >= 0 && j >= 0) {
                    temp = rst.charAt(rstPos) - '0' + timesRst.charAt(j) - '0' + carryIn;
                    rst.setCharAt(rstPos, (char) (temp % 10 + '0'));
                    carryIn = temp / 10;
                    rstPos--;
                } else if (rstPos < 0) {
                    // rst没有数字了
                    temp = timesRst.charAt(j) - '0' + carryIn;
                    rst.insert(0, temp % 10);
                    carryIn = temp / 10;
                } else {
                    // timesRst没有数字了
                    if (carryIn == 0) {
                        break;
                    } else {
                        temp = rst.charAt(rstPos) - '0' + carryIn;
                        rst.setCharAt(rstPos, (char) (temp % 10 + '0'));
                        carryIn = temp / 10;
                        rstPos--;
                    }
                }
            }

            if (carryIn != 0) {
                rst.insert(0, carryIn);
            }

            // 因为是左边开始乘的，每次都要左移一位
            if (i != len - 1) {
                rst.append('0');
            }
        }

        return rst.toString();
    }

    public static void main(String[] args) {
        P43 p = new P43();
        System.out.println(p.multiply("123", "456"));
    }
}
```

```
public class P43_new {
    public String multiply(String num1, String num2) {
        int[] rst = new int[num1.length() + num2.length()];
        int temp;

        // num1[i] * num2[j] 只会放在i + j和i + j + 1
        for (int i = num1.length() - 1; i >= 0; i--) {
            for (int j = num2.length() - 1; j >= 0; j--) {
                temp = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                rst[i + j + 1] += temp % 10;
                rst[i + j] += temp / 10;
            }
        }

        StringBuilder sb = new StringBuilder();
        int pos = rst.length - 1, carryIn = 0;
        // 找到第一个不为0的位置
        for (int i = 0, len = rst.length; i < len; i++) {
            if (rst[i] != 0) {
                pos = i;
                break;
            }
        }

        // 可能会有进位
        for (int i = rst.length - 1; i >= pos; i--) {
            sb.insert(0, (char) ((rst[i] + carryIn) % 10 + '0'));
            carryIn = (rst[i] + carryIn) / 10;
        }

        if (carryIn != 0) {
            sb.insert(0, (char) (carryIn + '0'));
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        P43_new p = new P43_new();
        System.out.println(p.multiply("123", "456"));
    }
}
```

## 44.Wildcard Matching	
Implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false

```

public class P44 {
    /*
     * 时间复杂度O(2^n)
     * "aaabbbaabaaaaababaabaaabbabbbbbbbbaabababbabbbaaaaba"
     * "a*******b"
     * 会超时
     */

    public boolean dfs(String s, int sPos, int sLen, String p, int pPos, int pLen) {
        if (pPos >= pLen) {
            return sPos >= sLen;
        }

        if (sPos < sLen && (s.charAt(sPos) == p.charAt(pPos) || p.charAt(pPos) == '?')) {
            // 各后移一位
            return dfs(s, sPos + 1, sLen, p, pPos + 1, pLen);
        } else if (p.charAt(pPos) == '*') {
            if (sPos < sLen) {
                // s没有匹配完，*不匹配 || * 匹配一个
                return dfs(s, sPos, sLen, p, pPos + 1, pLen)
                        || dfs(s, sPos + 1, sLen, p, pPos, pLen);
            } else {
                // s匹配完了(例如aa, aa***), *不匹配
                return dfs(s, sPos, sLen, p, pPos + 1, pLen);
            }
        } else {
            return false;
        }
    }

    public boolean isMatch(String s, String p) {
        return dfs(s, 0, s.length(), p, 0, p.length());
    }

    public static void main(String[] args) {
        P44 p = new P44();
        System.out.println(p.isMatch("aab", "a*b"));
    }
}
```
```
public class P44_new {
    /*
     * dp, 时间复杂度O(nm)
     * 状态转移方程
     * dp[i][j]表示s前i个和p前j个是否匹配
     * dp[i][j] = dp[i - 1][j - 1]   if s[i] == p[j] || p[j] == '?'
     * dp[i][j] = dp[i][j - 1] || dp[i - 1][j]   if p[j] == '*'
     * else dp[i][j] = false
     */

    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];

        // 初始话， 比如aa, *是匹配的
        dp[0][0] = true;
        for (int i = 1, pLen = p.length(); i <= pLen; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = true;
            } else {
                break;
            }
        }

        for (int i = 1, sLen = s.length(); i <= sLen; i++) {
            for (int j = 1, pLen = p.length(); j <= pLen; j++) {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }

        return dp[s.length()][p.length()];
    }

    public static void main(String[] args) {
        P44_new p = new P44_new();
        System.out.println(p.isMatch("aa", "*"));
    }
}
```


## 45.Jump Game II
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

For example:
Given array A = [2,3,1,1,4]

The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

Note:
You can assume that you can always reach the last index.

```
public class P45 {
    /*
     * 贪心，O(n)时间
     * 每次选当前跳的最远距离内能跳的最远距离
     */

    public int jump(int[] nums) {
        int nextMaxIndex = 0, curMaxIndex = -1, rst = 0;

        for (int i = 0, len = nums.length; i < len; i++) {
            // 在当前位置能跳的最远距离内，判断下一次能跳的最远距离
            if (i <= curMaxIndex) {
                if (i + nums[i] > nextMaxIndex) {
                    nextMaxIndex = i + nums[i];
                }
            } else {
                // 下一跳， 如果能跳到最后，直接返回
                curMaxIndex = nextMaxIndex;
                if (curMaxIndex >= len - 1) {
                    return rst;
                }
                rst++;
                // 这里需要i--，因为刚好>curMaxIndex这个位置能跳的最远距离没有计算
                i--;
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P45 p = new P45();
        int[] nums = {2, 3, 1, 1, 4};
        System.out.println(p.jump(nums));
    }
}
```


## 46.Permutations
Given a collection of distinct numbers, return all possible permutations.

For example,
[1,2,3] have the following permutations:

[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

```
import java.util.ArrayList;
import java.util.List;

public class P46 {
    /*
     * 递归，O(n!)时间
     * 假设dfs能排列curPos到len，每次把curPos换个数字，然后自动排列后面的
     */

    public void dfs(List<List<Integer>> rst, int[] nums, int curPos, int len, List<Integer> list) {
        if (curPos == len - 1) {
            list.add(nums[curPos]);
            rst.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        } else {
            for (int i = curPos; i < len; i++) {
                swap(nums, curPos, i);
                list.add(nums[curPos]);
                dfs(rst, nums, curPos + 1, len, list);
                list.remove(list.size() - 1);
                // 实际是可加可不加，加上后结果会比较整齐，但答案比较需要按顺序来，所以加上了
                swap(nums, curPos, i);
            }
        }
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        dfs(rst, nums, 0, nums.length, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P46 p = new P46();
        int[] nums = {1, 2, 3};
        List<List<Integer>> rst = p.permute(nums);
        for (List<Integer> list : rst) {
            for (int t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```


## 47.Permutations II
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

For example,
[1,1,2] have the following unique permutations:

[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]

```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class P47 {
    public void dfs(List<List<Integer>> rst, int[] nums, int curPos, int len, List<Integer> list) {
        if (curPos == len - 1) {
            list.add(nums[curPos]);
            rst.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        } else {
            Set<Integer> hasBeenInFirst = new HashSet<Integer>();
            for (int i = curPos; i < len; i++) {
                // 相同的数字只能出现在第一位一次
                if (!hasBeenInFirst.contains(nums[i])) {
                    hasBeenInFirst.add(nums[i]);
                    swap(nums, curPos, i);
                    list.add(nums[curPos]);
                    dfs(rst, nums, curPos + 1, len, list);
                    list.remove(list.size() - 1);
                    swap(nums, curPos, i);
                }
            }
        }
    }

    public void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> rst = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        dfs(rst, nums, 0, nums.length, new ArrayList<Integer>());

        return rst;
    }

    public static void main(String[] args) {
        P47 p = new P47();
        int[] nums = {1, 1, 1, 2, 3};
        List<List<Integer>> rst = p.permuteUnique(nums);
        for (List<Integer> list : rst) {
            for (int t : list) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }
}
```



## 48.Rotate Image

You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]


```
public class P48 {
    /*
     * 变换规律:
     * 列 -> 行
     * 行 -> (n - 行 + 1)列
     */
    public void rotate(int[][] matrix) {
        int len = matrix.length;
        int swapRow, swapColumn, temp;

        for (int row = 0; row < len / 2; row++) {
            for (int column = row; column < len - row - 1; column++) {
                // 四个数交换
                /*
                 * {11, 12, 13, 14},
                 * {21, 22, 23, 24},
                 * {31, 32, 33, 34},
                 * {41, 42, 43, 44}
                 *
                 * 11，14交换，14， 44交换，44， 41交换
                 */
                swapRow = column;
                swapColumn = len - row - 1;
                swap(matrix, row, column, swapRow, swapColumn);

                temp = swapRow;
                swapRow = swapColumn;
                swapColumn = len - temp - 1;
                swap(matrix, row, column, swapRow, swapColumn);

                temp = swapRow;
                swapRow = swapColumn;
                swapColumn = len - temp - 1;
                swap(matrix, row, column, swapRow, swapColumn);
            }
        }

        for (int[] row : matrix) {
            for (int t : row) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }

    public void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }

    public static void main(String[] args) {
        P48 p = new P48();
        int[][] matrix = {
                {11, 12, 13, 14},
                {21, 22, 23, 24},
                {31, 32, 33, 34},
                {41, 42, 43, 44}
        };

        p.rotate(matrix);
    }
}
```

```
public class P48_new {
    /*
     * 变换规律:
     * 列 -> 行
     * 行 -> (n - 行 + 1)列
     *
     * 列变行，用转置
     * 行变(n - 行 + 1)列，转置后，行变成了列，列再左右对称交换一下
     */

    public void rotate(int[][] matrix) {
        int len = matrix.length;

        // 转置，行列互换
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len; j++) {
                swap(matrix, i, j, j, i);
            }
        }

        // 列对称交换
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len / 2; j++) {
                swap(matrix, i, j, i, len - j - 1);
            }
        }

        for (int[] row : matrix) {
            for (int t : row) {
                System.out.print(t + " ");
            }
            System.out.println();
        }
    }

    public void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }

    public static void main(String[] args) {
        P48_new p = new P48_new();
        int[][] matrix = {
                {11, 12, 13, 14},
                {21, 22, 23, 24},
                {31, 32, 33, 34},
                {41, 42, 43, 44}
        };

        p.rotate(matrix);
    }
}
```


## 49.Group Anagrams

Given an array of strings, group anagrams together.

For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"], 
Return:

[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]


Note: All inputs will be in lower-case.

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class P49 {
    /*
     * 时间复杂度O(nk)，n为strs数组长度，k为字符串最长长度
     * 思路：统计字符串中每个字符出现次数，编码成字符串，加入哈希表，如果一样说明是同一类型
     * 编码可以用其他方法，比如素数，0到25字符对应一个素数，是这个数，乘上这个数，编码成了整数
     * 另一种思路，不统计字符出现次数，把字符串转成字符数组，排序，再加入哈希表，时间复杂度O(nklogk)
     */

    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> rst = new ArrayList<List<String>>();
        Map<String, Integer> map = new HashMap<String, Integer>();
        String str;

        for (int i = 0, len = strs.length; i < len; i++) {
            int[] temp = new int[26];
            str = strs[i];
            // 统计字符出现次数
            for (int j = 0, strLen = str.length(); j < strLen; j++) {
                temp[str.charAt(j) - 'a']++;
            }

            // 编码
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < 26; j++) {
                sb.append(temp[j] + '-');
            }

            // 如果已经在map中， 加入rst相应位置，否则加入map和rst
            if (map.containsKey(sb.toString())) {
                rst.get(map.get(sb.toString())).add(str);
            } else {
                map.put(sb.toString(), rst.size());
                List<String> list = new ArrayList<String>();
                list.add(str);
                rst.add(list);
            }
        }

        return rst;
    }

    public static void main(String[] args) {
        P49 p = new P49();
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        List<List<String>> rst = p.groupAnagrams(strs);
        for (List<String> list : rst) {
            for (String t : list) {
                System.out.print(t + " ");
            }

            System.out.println();
        }
    }
}
```

## 50.Pow(x, n)

Implement pow(x, n).

Example 1:

Input: 2.00000, 10
Output: 1024.00000


Example 2:

Input: 2.10000, 3
Output: 9.26100

```
public class P50 {
    /*
     * 快速幂，注意一下特殊情况就好
     * O(logn)时间，O(1)空间
     * 也可以用递归，每次分一半，O(logn)时间，O(logn)空间
     */

    public double myPow(double x, int n) {
        // 注意n为负数的情况
        boolean nIsNegative = n < 0;
        boolean nIsMaxNegative = n == Integer.MIN_VALUE;
        double xTemp = x;

        // 注意n为Integer.MIN_VALUE时，abs会溢出
        n = nIsMaxNegative ? Integer.MAX_VALUE : Math.abs(n);
        double rst = 1.0;
        // 快速幂
        while (n != 0) {
            if ((n & 1) == 1) {
                rst *= x;
            }

            n >>= 1;
            x *= x;
        }

        if (nIsMaxNegative) {
            rst *= xTemp;
        }

        return nIsNegative ? 1.0 / rst : rst;
    }

    public static void main(String[] args) {
        P50 p = new P50();
        System.out.println(p.myPow(-1, -2147483648));
    }
}
```

## 51.N-Queens
## 52.N-Queens II	
## 53.Maximum Subarray	
## 54.Spiral Matrix	
## 55.Jump Game	
## 56.Merge Intervals	
## 57.Insert Interval	
## 58.Length of Last Word	
## 59.Spiral Matrix II	
## 60.Permutation Sequence	
